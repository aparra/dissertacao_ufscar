\chapter{Treplica Reconfigurável}\label{cap2}

Descrever a proposta e sua implementação.

\section{Visão arquitetural de Treplica}

Introdução da arquitetura de treplica

\subsection{Componentes de suporte}

Comentar sobre a abstração dos componentes de suporte

\subsubsection{Transport}\label{subsec:transport}

\subsubsection{Change Log}

\subsubsection{Ledger}

Ledger é a abstração do estado persistente para implementação de Paxos. É uma estrutura
de dados comum, compartilhada por todos os agentes de Paxos, implementados por Treplica,
que conseguem através de uma interface acessar a memória principal. A implementação dessa
interface suporta persistência dos dados de forma não-volátil. Conforme definido no
\autoref{cap1:replicacao_ativa_paxos}, é possível obter o mesmo estado replicado a partir
das instâncias de consenso armazenadas em memória persistente. Assim, a abstração do
Ledger concentra todos os dados de uma instância de consenso bem sucedido em memória
persistente, facilmente acessível a partir da memória principal. A classe LoggingLedger é
o objeto utilizado para persistir em log (disco) as alterações. Para simplificar o uso de
log de alterações, esta implementação tem suporte para detectar e isolar as alterações
feitas em seu estado interno. Pode gravar mudanças no estado e depois recuperá-la,
reaplicando um conjunto de alterações previamente gravados. O Ledger armazena o estado
completo de cada instância do consenso por réplica, mantendo todos os dados exigidos por
todos os tipos de agentes de Paxos implementados por Treplica. Dessa forma, é possível que
qualquer agente recupere seu estado, inclusive o coordenador.

\subsubsection{Secretary}\label{subsec:secretary}

Secretary apresenta uma abstração unificada de I/O para os agentes de Paxos. Este
componente utiliza memória persistente usando \emph{change log} e o Ledger, lida com a
passagem de mensagens usando o componente de transporte e lida também com a fila de
objetos utilizada para entregar objetos para a aplicação. A principal razão para criação
dessa abstração em Treplica foi sintetizar as operações de I/O em \emph{threads}
diferentes das que executam as operações de Paxos. Operações de I/O em disco, tem grande
potencial para reduzir o desempenho do algoritmo Paxos por duas razões: (1) todas as
requisições de escrita que estabeleceram consenso, devem ser persistidas de forma
não-volátil antes do progresso do algoritmo. Premissa para garantir consistência; (2)
alguns passos do algoritmo de Paxos podem demandar muito acesso a memória persistente.
Considerando que cada operação de escrita em disco leva cerca de $1ms$ para ser concluída
e que uma rodada de Paxos, pelo menos, requer duas escritas em memória estável, acabamos
de adicionar uma latência de $2ms$ em todas as rodadas de consenso.

Uma vez que o I/O é tratado apenas pelo Secretary de forma assíncrona é possível resolver
o problema de falta de paralelismo entre as rodadas. Isso é feito através de uma fila de
agrupamento de gravações lógicas distintas que retém os dados realizar uma única gravação
física. Essa abordagem é vantajosa porque o tamanho dos dados de escrita no disco, utiliza
uma \emph{sync() system call} causando um pouco latência na operação. A implementação d
de Scretary absorve latência da \emph{system call} mantendo uma \emph{thread} separada
para persistência dos dados.

\subsubsection{Router}

Router é um componente simples, mas vital para PaxosPersistentQueue, porque inicia todos
os agentes em conjunto. Sua função principal é prover o \emph{main loop} da implementação
de Paxos, que recebe mensagens do componente de transporte e, de acordo com seu tipo,
encaminha para o agente apropriado. Dessa forma, a execução desse agente é sequencial e
compartilha estruturas de dados, como o Ledger, não precisa de controle de concorrência.

Esse é o único componente (\emph{thread}) que monitora o temporizador central e gera
eventos de \emph{timer} \footnote{Os eventos de \emph{timer} simbolizam a passagem do
tempo para a aplicação. Esse evento atinge todos os componentes que necessitam de um
relógio para seu correto funcionamento}. O código de processamento dos agentes não possuem
operações que geram grandes bloqueios, eles são programados como simples manipuladores de
eventos caracterizando uma arquitetura de processamento assíncrono baseada em eventos
(\emph{event-based}). É responsabilidade do Router instanciar agentes e componentes de
apoio e, também, inicializar a PaxosPersistentQueue.


\subsection{Componentes de Paxos}

Falar sobre a abstração dos componentes de Paxos

\subsubsection{Election}

\subsubsection{Learner}

\subsubsection{Coordinator}

Coordenador (\emph{coordinator}) é o agente responsável por conduzir a rodada de consenso.
Ele é capaz de decidir, através da aplicação de uma regra local, se uma rodada foi bem
sucedida ou não. A regra local do coordenador é baseada em quóruns de \emph{receptores} e
exige que pelo menos $\lfloor n/2 \rfloor + 1$ receptores façam parte de uma rodada, onde
$n$ é o número total de receptores na aplicação \cite{lamport98}.

É permitido a existência de apenas um coordenador por rodada, em caso de falha na réplica
que executa o agente coordenador, uma eleição de líder deve ser convocada para estabelecer
que uma réplica correta execute o agente coordenador. Como o algoritmo é executado no
modelo computacional falha-e-recuperação, a réplica defeituosa pode voltar a computação
acreditando que ainda é o coordenador. Nesse caso, uma nova eleição de líder deve ser
convocada novamente para restabelecer a unicidade de coordenador por rodada.

\subsubsection{Proposer}

Proponente (\emph{proposer}) são agentes capazes de propor valores. Os proponentes podem
propor dois valores diferentes concorrentemente (condição de concorrência)
\footnote{Também conhecida como condição de corrida, acontece quando diferentes processos
em execução atuam sobre um estado compartilhado \cite{alguem}}, nesse caso suas propostas
podem colidir inviabilizando o sucesso de uma rodada de consenso. Em caso de colisões,
diferentes mecanismos podem ser implementados, para lida com essa situação Treplica inicia
uma nova rodada por intermédio do agente \emph{coordenador}.

\subsubsection{Acceptor}


\section{Alterações propostas}

Descrever o objetivo dessa secao

\subsection{Paxos com Réplicas Leitoras}

A ideia principal da abordagem proposta é utilizar réplicas que não participem do processo
de decisão de instâncias de consenso. Isso é feito com a adoção de \emph{réplicas
leitoras}, que são réplicas onde apenas parte dos agentes do algoritmo Paxos estão
executando. Para maior clareza de exposição, quando necessário, chamaremos as réplicas
contendo todos os agentes ativos de \emph{réplicas votantes}. Para suportar a adaptação
elástica a novos perfis de desempenho, desenvolvemos um mecanismo para o
\emph{provisionamento de réplicas} e uma \emph{política de reconfiguração}.

\subsubsection{Réplicas Leitoras}

Réplicas leitoras são réplicas onde apenas os agentes proponente e aprendiz estão
executando. Dessa forma, do ponto de vista do conjunto de processos que implementam o
algoritmo Paxos, uma réplica leitora é capaz apenas de propor operações a serem aplicadas
no estado replicado e de aprender operações decididas pelo conjunto de receptores. Do
ponto de vista do cliente da aplicação replicada um réplica leitora se comporta como uma
réplica votante: ela atende requisições de qualquer tipo garantindo a execução atômica das
mesmas.

As réplicas leitoras não assumem um papel fundamental na execução do algoritmo Paxos, no
entanto elas se integram de forma consistente com a operação das réplicas votantes por
meio de suas funções fundamentais: propor e aprender requisições de escrita. As réplicas
leitoras propõem novas requisições a serem executadas em nome de seus clientes através de
seu agente proponente. O proponente encaminha a operação ao coordenador que por sua vez
decide, em conjunto com os receptores, a ordem da mesma através de uma rodada de Paxos,
como descrito no \autoref{cap1:replicacao_ativa_paxos}. Uma vez que a decisão é alcançada,
a mesma é difundida para o resto do sistema. Nesse momento o agente aprendiz da réplica
leitora toma conhecimento da decisão e atualiza o seu estado interno, sem a participação
ativa do coordenador ou de qualquer receptor.

Tanto o processo de proposta quanto o de aprendizado executado por uma réplica leitora
devem usar as mesmas estratégias de implementação das réplicas votantes. Na verdade, em
nossa implementação usando Treplica, as réplicas leitoras foram construídas a partir da
separação modular dos agentes que implementam Paxos. Dessa forma, reutilizamos os mesmos
componentes e por consequência essas réplicas são capazes de detectar e reenviar propostas
perdidas, detectar e corrigir lacunas na sequência de instâncias de consenso, fazer
controle de fluxo e de congestionamento, entre outras operações fundamentais para uma
operação eficiente de Paxos \cite{vieira-tr10b}.

Uma consequência importante do uso de réplicas leitoras é que essas réplicas,
consistentemente com as funções que elas assumem no algoritmo Paxos, não precisam de
memória persistente para sua operação. Isso se deve ao fato de que elas não executam as
Fases 1 e 2 do algoritmo. Porém, pode ser interessante que essas réplicas registrem a
proposta decidida de forma a não precisar realizar uma recuperação completa em caso de
falha. Na nossa proposta de réplicas leitoras decidimos não fazer esse registro de forma a
remover completamente a escrita em memória persistente do caminho crítico de execução. É
interessante observar que a escrita eliminada ocorre somente quando a réplica leitora
atualiza o seu estado de acordo com as propostas decididas pelos receptores das réplicas
votantes. Dessa forma, as réplicas leitoras conseguem manter seu estado atualizado com as
réplicas votantes com um custo mínimo. Elas também são capazes de processar requisições de
escrita com um custo similar àquele gerado pelas réplicas votantes ao executar as mesmas
requisições. Podemos argumentar que esse custo é menor, na medida que as réplicas leitoras
aliviam as réplicas votantes do custo de manter as conexões abertas com os clientes.

Utilizando réplicas leitoras, podemos formar grupos de réplicas com diferentes graus de
uso de memória persistente \cite{aguilera00}. Uma configuração simples seria mesclar
réplicas votantes e leitoras formando um conjunto híbrido de réplicas transparente para o
cliente, conforme ilustra a \autoref{fig:configuracao_replicas_leitoras} (a). É concebível
ainda uma configuração onde as réplicas votantes não entram em contato com os clientes,
sendo essa operação completamente delegada às replicas leitoras, configuração ilustrada
pela \autoref{fig:configuracao_replicas_leitoras} (b).

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=16cm]{conteudo/capitulos/figuras/configuracao_replicas_leitoras.eps}
  \end{center}
  \caption{Configuração de Paxos com réplicas votantes e leitoras}
  \label{fig:configuracao_replicas_leitoras}
\end{figure}

As réplicas leitoras funcionam então como uma espécie de cache \emph{write-through}
distribuído. O estado replicado na memória destas réplicas permite atender diretamente as
requisições de leitura dos clientes, enquanto as requisições de escrita são repassadas ao
receptores. Podemos ver claramente que a taxa de acerto desse cache está diretamente
ligada à proporção de operações de leitura geradas pelos clientes e que a vazão de
operações de leitura tem o potencial de crescer linearmente com o número de réplicas
leitoras disponíveis.

\subsubsection{Componentes alterados}

Antes de detalharmos as alterações realizadas, vamos recapitular de forma resumida a
iteração entre os agentes de Paxos: proponentes enviam a sua proposta para o coordenador
que tenta alcançar consenso sobre a proposta em uma rodada, sendo que cada proposta
corresponde a uma ou mais requisições de escrita da aplicação sendo replicada.

Anteriormente, era possível uma única configuração de réplicas que empregava todos os
agentes de Paxos utilizando memória persistente. A nova funcionalidade de réplicas
leitoras foi implementada através de uma segregação modular dos agentes utilizados por uma
réplica votante:

\begin{itemize}
  \item Proponente: agente capaz de propor valores;
  \item Receptor: agente que vota em uma única proposta por rodada;
  \item Aprendiz: agente que aprende a decisão de consenso;
  \item Coordenador: agente responsável por garantir o funcionamento do algoritmo a cada
    rodada de consenso executada.
\end{itemize}

A classe denominada \classname{PaxosPersistentQueue} é responsável por implementar o
agrupamento de todos esses agentes, caracterizando assim uma réplica votante. Podemos
definir, do ponto de vista de uma Máquina Virtual Java (JVM), que uam réplica votante
possui como uma das suas \emph{threads} ativas o \emph{main loop} da classe
\classname{PaxosPersistentQueue}. Em contra partida, uma réplica leitora, executa o
\emph{main loop} da classe \classname{PaxosReadonlyQueue}. Essa classe, implementa somente
a agregação dos agentes proponente e aprendiz, sem a utilização de memória persistente.
Detalharemos nas próximas seções a implementação proposta para esse componente.

\subsubsubsection{PaxosReadonlyQueue}

A classe \classname{PaxosReadonlyQueue} foi criada para fornecer o mesmo comportamento da
classe \classname{PaxosPersistenteQueue}: disponibilizar uma fila que será utilizada pelo
protocolo Paxos. No entanto, as operações suportadas por \classname{PaxosReadonlyQueue}
não as mesmas. Do ponto de vista do processamento de mensagens postadas na fila, as
seguintes propriedades foram supostas para caracterizar uma réplica leitora:

\begin{itemize}
  \item Abdicar liderança: todas as mensagens relacionadas a eleição de líder não são
    processadas, logo é eliminada qualquer possibilidade de uma réplica leitora se tornar
    coordenadora de uma rodada de Paxos.
  \item Inelegível ao voto: mensagens relacionadas a votação de uma proposta são
    ignoradas. Dessa forma, réplicas leitoras não participam do processo de decisão de
    consenso e não são essenciais para o progresso do algoritmo Paxos.
  \item Aprendizado: todas as mensagens endereçadas ao componente \classname{Learner} são
    processadas pela fila. Consequentemente, os mecanismos descobrir qual foi o consenso
    de uma determinada rodada são habilitados.
\end{itemize}

O principal objetivo dessa classe é participar das operações que não exigem dados
persistentes para garantir correção do algoritmo, oferecendo instâncias capazes de atuar
parcialmente nas fases de Paxos. Do ponto de vista do cliente da aplicação um réplica
leitora se comporta como uma réplica votante: ela atende requisições de qualquer tipo
garantindo a execução atômica das mesmas. Sendo assim, as seguintes premissas não podem
ser violadas:

\begin{itemize}
  \item Mensagens quem alteram o estado (escrita): são resolvidas pelo aglomerado de
    réplicas orquestrado pelo protocolo Paxos, porém réplicas que não possuem grau de
    memória persistente não participam da decisão de consenso.
  \item Mensagens que não alteram estado (leitura): são resolvidas localmente independente
    do grau de memória da réplica.
\end{itemize}

Do ponto de vista de uma réplica votante, não é possível distinguir se a proposta é
oriunda de uma réplica votante ou leitora. O mecanismo para configuração do grau de
memória de uma réplica em Treplica atua de forma transparente junto com protocolo Paxos,
respeitando a forte premissa: o número de réplicas leitoras nunca deve afetar o número de
réplicas votantes. Sendo assim, podemos afirmar que o progresso e a correção do algoritmo
não são violados.

Réplicas oferecem um poder de manobra para aliviar a carga de processamento das réplicas
votantes com relação a mensagens de leituras, podendo ser configuradas de tal forma que
nenhuma mensagem de leitura seja processada por uma réplica votante. Avaliar e propor
soluções para configuração do conjunto de réplicas não faz parte do escopo desse trabalho.

\subsubsubsection{WeakSecretary}

A classe \classname{WeakSecretary} apresenta uma abstração de I/O sem persistência de
dados em disco. Esse componente é uma versão leve da classe \classname{Secretary}
(\autoref{subsec:secretary}), ela é utilizada pelos agentes de Paxos para enviar mensagens
pela rede, através do intermédio do componente \classname{Transport}
(\autoref{subsec:transport}). Essa classe foi projetada para trabalhar com dados somente
em memória, dessa forma todos os dados computados são perdidos na presença de defeitos na
réplica. No entanto, na ausência de falhas nos beneficiamos da eliminação de uma operação
custosa relacionada com I/O em disco.

\classname{WeakSecretary} também é responsável por lidar com o componente
\classname{Ledger} (\autoref{subsec:ledger}) e com a fila de objetos utilizada
para entregar mensagens para a camada da aplicação. A principal razão para a criação dessa
abstração em Treplica foi eliminar a operação de persistência em disco, gerando um
componente volátil, capaz de oferecer as operações essenciais para o progresso do
algoritmo sem o ônus da escrita em disco.

\subsubsection{Provisionamento de Réplicas Leitoras}

É possível utilizar os mecanismos tradicionais de Treplica para provisionar uma nova
réplica leitora. Em resumo, uma réplica que se integra ao sistema pela primeira vez ou
após uma falha demorada deve recuperar o seu estado. Esse processo acontece através de um
mecanismo de preenchimento de lacunas, que observa que não pode executar novas requisições
de escrita sem antes executar as requisições anteriores \cite{vieira-tr10b}. Esse
procedimento é voltado para reparar pequenas interrupções e não a recuperação do estado
completo de uma réplica. Em particular, no caso de uma réplica leitora sem estado
persistente, o tamanho dessa recuperação pode ser muito grande em termos do número de
\emph{requisições} a serem reexecutadas, pois ela sempre parte do estado inicial vazio.

Foi necessário então criar um procedimento de provisionamento de réplicas, de forma a
permitir o rápido início de uma réplica leitora. Esse mecanismo não é necessariamente
exclusivo de réplicas leitoras e pode ser aplicado a réplicas normais. Porém, neste
primeiro momento, ele tira proveito do fato dessas réplicas não terem memória persistente.
Em particular, a adição ou remoção de uma réplica leitora não altera o número de
receptores executando o algoritmo, não havendo necessidade de se realizar um
reconfiguração custosa \cite{lamport10}.


\subsection{Protocolo para transferência de estado}

Para que a agregação de uma nova réplica seja produtiva, é preciso realizar a
transferência completa de um estado inicial que deve ser clonado de outra réplica já
ativa, votante ou leitora. Por questões de garantia de consistência, a transferência de
estado é uma tarefa síncrona. A réplica leitora está apta a processar as requisições de
leitura ou escrita somente após o recebimento do estado inicial. E, enquanto ela aguarda,
essas requisições são ignoradas. A réplica que doará seu estado não deve processar nenhuma
operação de escrita enquanto realiza a transferência de estado. Essa é uma atividade
potencialmente custosa para o desempenho de Paxos, pois estamos bloqueando,
temporariamente, a participação de uma réplica no processo de decisão de instâncias de
consenso.

Visando minimizar a degradação de desempenho causada pela necessidade de transferência de
estado, criamos um protocolo simples e eficaz para reger a junção de novas réplicas
leitoras à computação, conforme ilustrado na \autoref{fig:protocolo}. Durante o processo
de transferência de estado, supomos que a réplica interessada em receber um novo estado é
sempre uma réplica leitora e que a réplica que fornece esse estado pode ser tanto uma
réplica leitora quanto votante. No restante da seção chamaremos essas réplicas de réplicas
doadoras.

\begin{figure}[ht]
  \centering
  \includegraphics[width=11cm]{conteudo/capitulos/figuras/transferencia_estado.eps}
  \caption{Protocolo de Transferência de Estado}
  \label{fig:protocolo}
\end{figure}

Estabelecemos a premissa de que é responsabilidade da réplica leitora encontrar uma
réplica disposta a transferir seu estado. A elegância do mecanismo de seleção de doador é
herdada do Treplica: as réplicas conhecem somente seu próprio identificador de rede e
podem alcançar todas as outras réplicas por uma primitiva simples de difusão. Quando
iniciamos uma réplica leitora ela difunde uma mensagem (PredicateMessage) com o
valor da última instância de consenso decidida. Essa mensagem é o início do protocolo de
transferência de estado que explicitamente informa a existência de uma nova réplica
tentando se juntar à computação e de que é preciso fornecer a ela um estado inicial.

As réplicas que recebem a mensagem solicitando o estado são solidárias e tentam atender a
essa requisição caso sua última instância decidida seja maior que a recebida no pedido de
estado. Neste caso, elas enviam uma mensagem (ACKMessage) somente para o remetente
do pedido de estado, com as informações sobre o seu estado atual (última instância de
consenso e um indicador do tipo de réplica: leitora ou votante). Devido à restrição de
sincronia de transferência de estado é preferível que a réplica leitora encontre outra
réplica leitora para ser sua doadora de estado, tentando minimizar possíveis impactos na
computação de Paxos.

Estabelecemos o tempo máximo de 5 segundos para que a réplica leitora selecione uma
réplica doadora e inicie a transferência de estado. Todas as respostas ao seu pedido de
transferência de estado são armazenadas em memória, a espera de uma réplica doadora que
satisfaça os requisitos para a doação de estado. Caso o tempo limite seja alcançado e no
conjunto de possíveis doadoras não exista nenhuma réplica leitora, uma réplica votante
será selecionada. Selecionar uma réplica votante para transferir estado pode impactar
diretamente no desempenho da aplicação, porque essa máquina não participará da eleição do
novo estado durante o período de transmissão. Em Paxos, a partir do momento em que a
maioria dos receptores concordam com a alteração do estado, mais cedo ou mais tarde todas
as réplicas chegarão a um consenso. A partir do momento que retiramos da computação uma
réplica votante, a probabilidade de atingir consenso pela maioria diminui, podendo até
impossibilitar o progresso do algoritmo.

Dado que o estado de uma aplicação pode ser tão grande quanto a capacidade de memória de
uma réplica e que todas as mensagens de Treplica são trocadas via protocolo UDP, optamos
por aumentar a vazão da transferência de estado usando o protocolo TCP. Somente o estado é
enviado via TCP, todas as outras mensagens utilizam a comunicação UDP nativa de Treplica.
Sendo assim, a réplica leitora abre um \emph{socket} TCP e envia uma mensagem
(GETMessage) para a réplica doadora com o endereço do \emph{socket} TCP para envio de
estado. A réplica doadora bloqueia suas atividades, estabelece a conexão TCP com a réplica
leitora e transfere seu estado.

Assim que a transferência de estado é concluída, a conexão TCP entre as réplicas é
finalizada, a réplica doadora volta para computação e a réplica leitora começa a processar
as requisições encaminhadas pelos seus clientes. Caso todas as etapas do protocolo de
transferência de estado não sejam concluídas em no máximo 10 segundos, a negociação de
estado  é reiniciada até que se obtenha êxito e uma nova  réplica leitora seja adicionada
ao sistema.

\subsubsection{Componentes alterados}

Descrever todos os componentes alterados para a utilização desse mecanismo

\subsubsection{Política de Reconfiguração}

O mecanismo descrito na seção anterior deve ser regido por uma política de criação e
remoção de réplicas leitoras. A  motivação por trás da criação de réplicas leitoras é
permitir que o sistema reaja de forma autônoma a picos de carga sem comprometer o
desempenho do mesmo. No entanto, sem uma política cuidadosa de reconfiguração corre-se o
risco de gastar muitos dos recursos do sistema no próprio processo de reconfiguração,
anulando quaisquer ganhos advindos do acréscimo de novas réplicas leitoras.

A política de reconfiguração deve, desta forma, ser um equilíbrio entre o custo de se
instanciar uma nova réplica leitora e os ganhos de desempenho a serem auferidos após esta
instanciação. O trabalho de especificação de parâmetros para esta política ainda está em
seu estágio inicial, dependendo de estudos mais aprofundados para caracterizar os custos
envolvidos.



\subsection{Alterações Propostas - Componente n}

:se...

