\chapter{Avaliação e Resultados}\label{cap3}

O \autoref{cap1:treplica_reconfiguravel} apresentou três funcionalidades para expansão da
biblioteca Treplica:

\begin{enumerate}
  \item Protocolo para transferência de estado: criação de um mecanismo eficiente para
    transferência de estado entre réplicas.
  \item Réplicas leitoras: possibilidade da utilização de réplicas que não participam do
    processo de decisão de instâncias de consenso.
  \item Equalização de estado: proposta para novo componente de preenchimento de lacunas
    originadas por possíveis períodos de instabilidade da réplica e/ou falhas.
\end{enumerate}

Supomos duas hipóteses baseado-se nas alterações propostas 1 e 2. A alteração proposta
pelo item 3 não será validada por esse trabalho. Mantivemos a descrição dessa alteração
para enriquecimento do conteúdo e possível utilização em trabalhos futuros.

\begin{enumerate}
  \item Se possuirmos um mecanismo transferência eficiente, podemos recuperar o estado de
    uma réplica de forma mais eficiente que a aplicação do histórico de decreto do
    aglomerado. Lembrando que, toda réplica votante armazena em memória persistente
    qualquer alteração realizada no seu estado.
  \item Se possuirmos uma réplica que evite a reconfiguração total do sistema, ganharemos
    o poder de manobra necessário para expansão do aglomerado de acordo com a demanda de
    clientes.
\end{enumerate}

Para validar que a hipótese 1 e 2 podem aumentar o desempenho de um sistema que utiliza a
biblioteca Treplica, supomos uma carga de trabalho na qual uma parcela significativa das
requisições solicitadas para aplicação seja de leitura. Essa é uma suposição razoável para
a maioria das aplicações de Internet \cite{tpc02} e proporciona o cenário, que acreditamos
ser o mais adequado, para execução eficiente utilizando réplicas leitoras.

Começamos esse capítulo com a \autoref{sec:aplicacao}, apresentando os detalhes da
aplicação e as bibliotecas utilizadas para sua concepção. Em seguida, na
\autoref{sec:ambiente_experimental} descrevemos o ambiente experimental usado na execução
dos experimentos. As próximas duas seções \autoref{sec:experimento_tranferencia_extado} e
\autoref{sec:experimento_replicas_leitoras} apresentam respectivamente os experimentos de
transferência de estado e réplicas leitoras com seus respectivos cenários, resultados e
análise. Encerramos o capitulo com a \autoref{sec:trabalhos-relacionados} apresentando as
considerações finais.


\section{Aplicação}\label{aplicacao}

Para fins experimentais, desenvolvemos então, visando a validação do conjunto de
experimentos, uma aplicação Web simples que mapeia uma cadeia de caracteres para um valor
numérico de 32 bits. Em outras palavras, criamos uma aplicação caracterizada como um mapa
que disponibiliza dois serviços aos clientes remotos através de uma interface HTTP:

\begin{enumerate}
  \item Operação GET \cod{/replicated-map/map/key/<chave>}
  \item Operação PUT \cod{/replicated-map/map/key/<chave>/value/<valor>}
\end{enumerate}

A operação GET é uma operação de leitura, sua função proporciona ao cliente buscar o valor
armazenado em uma determinada chave. Definimos que uma operação bem-sucedida no método GET
retorna o código de status HTTP 200 e um JSON com o valor da chave requisitada
\verb|{"value":"<valor>"}|. Por outro lado, o método PUT defini operações de escrita, ele
é responsável por armazenar um valor em uma determinada chave. Definimos que uma operação
de escrita sem falhas não possui corpo de retorno, o método retorna apenas o código de
status HTTP 201.

Utilizamos a linguagem Scala\footnote{http://www.scala-lang.org} para criação da
aplicação, sendo que o estado da aplicação é gerenciado pela biblioteca Treplica que atua
como um \emph{middleware} de replicação ativa, conforme ilustra a figura
\autoref{fig:treplica_como_middleware}. Treplica é uma biblioteca Java e mostrou boa
interoperabilidade com a aplicação. Não relatamos nenhum problema oriundo da utilização de
bibliotecas Java com a linguagem Scala.

\begin{figure}[ht]
  \centering
  \includegraphics[width=12cm]{conteudo/capitulos/figuras/block-treplica.eps}
  \caption{Treplica como \emph{middleware} de replicação ativa}
  \label{fig:treplica_como_middleware}
\end{figure}

Apesar da simplicidade encontrada na aplicação de teste, ela é executada em um aglomerado
de máquinas e oferece pra seus clientes, a garantia de que toda operação de escrita será
replicada para outras instâncias de forma ativa. Com base nessa propriedade, garantimos a
elegibilidade dessa aplicação para execução de experimentos no modelo computacional
utilizando replicação ativa.

Cada uma das réplicas instanciadas possui seu próprio estado e podem assumir diferentes
graus de persistência para dos dados em memória, definido-as como réplicas votantes ou
réplicas leitoras:

\begin{itemize}
  \item Réplica votante: utiliza memória persistente, premissa do algoritmo Paxos para
    garantia de correção no modelo computacional falha-e-recuperação.
  \item Réplica leitora: utiliza memória volátil.
\end{itemize}

\subsection{Dependências}

A \autoref{tab:dependencias} lista as bibliotecas dependentes, com a respectiva versão
utilizada, utilizadas para compilação e execução da aplicação. A tabela lista também a
responsabilidade que a biblioteca exerce no projeto.

\begin{table}[htbp]
\caption{Tabela de dependência de bibliotecas.}
\label{tab:dependencias}
\begin{center}
\begin{tabular}{ll}\hline\hline\hline
  Biblioteca & Versão & Responsabilidade \\
  treplica   & 0.3.2  & \emph{midleware} de replicação ativa \\
  vraptor \footnote{http://vraptor3.vraptor.org} & 3.5.1  & controlador MVC
    \footnote{Model-View-Controller, é um padrão de projeto de software que separa a
    representação da informação da iteração do usuário \cite{alguem} \\
\hline\hline\hline
\end{tabular}
\end{center}
\end{table}


\section{Descrição do Ambiente Experimental}\label{sec:ambiente_experimental}

Os experimentos foram realizados em um aglomerado com 16 nós, interligados através de um
\eng{switch} Ethernet de 1 Gbps. Cada nó possui a seguinte capacidade de processamento:

\begin{itemize}
  \item 1 processador Xeon E5620 (2.4 GHz, 6 \emph{threads});
  \item 12 GB de memória RAM;
  \item 500 GB de armazenamento local (disco 7200 rpm);
  \item Plataforma de 64 bits;
\end{itemize}

Os nós utilizam o sistema operacional GNU/Linux Debian 6.0. A \autoref{tab:aplicativos}
lista os aplicativos e suas respectivas versões que foram utilizados para execução dos
experimentos.

\begin{table}[htbp]
\caption{Tabela de conversão de acentuação.}
\label{tab:aplicativos}
\begin{center}
\begin{tabular}{ll}\hline\hline\hline
  Aplicativo & Versão                   & Descrição            \\
  JVM        & HotSpot 64-Bit 1.7.0\_45 & Máquina Virtual Java \\
  Apache Tomcat \footnote{http://tomcat.apache.org} & 7.0.32 & \emph{Servlet container} \\
  HAProxy \footnote{http://www.haproxy.org} & 1.5-dev19 & \emph{HTTP Load balancer} \\
\hline\hline\hline
\end{tabular}
\end{center}
\end{table}

O conjunto de réplicas é gerenciado por um servidor balanceador de carga configurado com
HAProxy, usado para melhorar o desempenho de serviços Web distribuindo requisições entre
vários servidores. Todas as requisições dos clientes passam pelo HAProxy, configurado para
receber e rotear as requisições para as réplicas ativas, usando um algoritmo de
revezamento circular (\eng{round-robin}), como ilustrado na \autref{fig:setup}. Nessa
configuração os processos clientes não compartilham recursos com os processos da
aplicação, ou seja, ou a instância executa processos clientes ou executa processos da
aplicação.

\begin{figure}[ht]
  \centering
  \includegraphics[width=7cm]{conteudo/capitulos/figuras/experimental-setup.dia.eps}
  \caption{Configuração experimental}
  \label{fig:setup}
\end{figure}

\subsection{Carga}

O programa de teste tem por objetivo produzir a carga de trabalho requirida pelos
experimentos e coletar medidas de vazão do ponto de vista do cliente. Sendo assim, o
programa de teste, em cada instância, registra em \emph{log} o \emph{timestamp} de início
e fim de cada atividade para que seja possível o computar a vazão alcançada pela
aplicação.

Para geração da carga de trabalho utilizamos processos Java que executam requisições de
leitura (requisições para o método HTTP GET) e escrita (requisições para o método HTTP
PUT) respeitando um percentual configurável para realização de cada operação. Para todos
os experimentos dedicamos 5 máquinas para atuarem como clientes, sendo que cada uma
executa 1000 requisições/segundo, variando (sem garantia de ordem) entre requisições de
leitura e escrita.

Do ponto de vista da aplicação, requisições de leitura serão atendidas localmente por uma
das réplicas, enquanto uma requisição de escrita será transformada em uma proposta e
submetida a uma rodada de consenso entre as réplicas votantes. Avaliando-se o custo de
cada tipo de requisição, podemos afirmar que requisições de escritas são mais caras porque
envolvem mais trocas de mensagens que requisições de leitura.

Cada teste identificará o percentual de execução de cada operação. A partir dessa
configuração, foi gerado uma carga total para aplicação de 5000 requisições/segundo. O
tempo total de execução de cada teste foi de 180 segundos, sendo que desse tempo foram
descartados os 20 segundos iniciais e finais, totalizando 140 segundos de execução
estável. O desempenho foi medido através da quantidade de requisições HTTP atendidas e o
tempo de resposta.

\section{Experimento Transferência de Estado}\label{sec:experimento_tranferencia_estado}

\fbox{\begin{minipage}
  Lorem ipsum dolor sit amet, his at eruditi civibus. Mei mucius labores delicata ut,
  fuisset qualisque ut sea, pro invidunt theophrastus ei. Alterum accusam usu ex, id duo
  verear sapientem. Pro velit minim oblique et, diam meis ea usu. Per at tantas deserunt,
  lorem laboramus ca vel. Lobortis concludaturque mel ex, at liber viderer delicatissimi
  eos, eu vel altera sadipscing. Ad cum unum posse urbanitas. Vim idque hendrerit cu, homero
  bonorum omittam cu pro. Idque doming eu his, his te alias hinc.
\end{minipage}}

Cenários, carga, servidores

Resultados

Análise

\section{Experimento Elástico}\label{sec:experimento:replicas_leitoras}

Cenários, carga, servidores

Resultados

Análise


Descrever a proposta e sua implementação.

